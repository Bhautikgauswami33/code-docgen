"""
Professional Documentation Generator and Exporter
Analyzes codebase and generates standardized documentation with watermarks
"""

import os
import re
import ast
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch, cm
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT, TA_JUSTIFY

class CodebaseAnalyzer:
    """Analyzes the codebase structure and extracts key information"""
    
    def __init__(self, root_dir: str):
        self.root_dir = root_dir
        self.languages = {}
        self.file_count = 0
        self.total_lines = 0
        self.frameworks = set()
        
    def analyze(self) -> Dict[str, Any]:
        """Perform full codebase analysis"""
        for root, _, files in os.walk(self.root_dir):
            for file in files:
                if file.startswith('.') or 'node_modules' in root:
                    continue
                    
                file_path = os.path.join(root, file)
                ext = os.path.splitext(file)[1].lower()
                
                # Count files by language
                if ext:
                    self.languages[ext] = self.languages.get(ext, 0) + 1
                    self.file_count += 1
                    
                # Count lines and detect frameworks
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        self.total_lines += len(content.splitlines())
                        
                        # Detect frameworks
                        if 'react' in content.lower():
                            self.frameworks.add('React')
                        if 'django' in content.lower():
                            self.frameworks.add('Django')
                        if 'vue' in content.lower():
                            self.frameworks.add('Vue.js')
                        if 'angular' in content.lower():
                            self.frameworks.add('Angular')
                except:
                    pass
                    
        return {
            'languages': self.languages,
            'file_count': self.file_count,
            'total_lines': self.total_lines,
            'frameworks': list(self.frameworks)
        }

class DocumentationGenerator:
    """Generates professional documentation with watermark"""
    
    def __init__(self):
        self.styles = getSampleStyleSheet()
        self._setup_styles()
        
    def _setup_styles(self):
        """Setup professional document styles"""
        self.title_style = ParagraphStyle(
            'CustomTitle',
            parent=self.styles['Title'],
            fontSize=24,
            spaceAfter=30,
            spaceBefore=30,
            textColor=colors.HexColor('#1e40af'),
            alignment=TA_CENTER
        )
        
        self.heading_style = ParagraphStyle(
            'CustomHeading',
            parent=self.styles['Heading1'],
            fontSize=18,
            spaceAfter=12,
            spaceBefore=24,
            textColor=colors.HexColor('#1e40af')
        )
        
        self.body_style = ParagraphStyle(
            'CustomBody',
            parent=self.styles['Normal'],
            fontSize=11,
            spaceBefore=6,
            spaceAfter=12,
            textColor=colors.HexColor('#374151')
        )
        
        self.watermark_style = ParagraphStyle(
            'Watermark',
            parent=self.styles['Normal'],
            fontSize=8,
            textColor=colors.HexColor('#94a3b8'),
            alignment=TA_CENTER
        )

    def create_watermark(self, canvas, doc):
        """Add professional watermark to each page"""
        canvas.saveState()
        canvas.setFillColorRGB(0.9, 0.9, 0.9)
        canvas.setFont('Helvetica', 8)
        text = f'Generated by CodeDocGen â€¢ {datetime.now().strftime("%Y-%m-%d %H:%M")}'
        canvas.drawString(doc.leftMargin, doc.bottomMargin - 20, text)
        canvas.restoreState()

    def generate_documentation(self, analysis_data: Dict[str, Any], output_path: str) -> str:
        """Generate professional PDF documentation with analysis results"""
        
        doc = SimpleDocTemplate(
            output_path,
            pagesize=A4,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=72
        )
        
        story = []
        
        # Title
        story.append(Paragraph("Codebase Analysis Report", self.title_style))
        story.append(Spacer(1, 30))
        
        # Executive Summary
        story.append(Paragraph("Executive Summary", self.heading_style))
        story.append(Paragraph(
            f"This report presents an analysis of the codebase containing {analysis_data['file_count']} "
            f"files across {len(analysis_data['languages'])} different languages, "
            f"with a total of {analysis_data['total_lines']} lines of code.",
            self.body_style
        ))
        story.append(Spacer(1, 20))
        
        # Languages Breakdown
        story.append(Paragraph("Language Distribution", self.heading_style))
        language_data = []
        for ext, count in analysis_data['languages'].items():
            percentage = (count / analysis_data['file_count']) * 100
            language_data.append([ext, count, f"{percentage:.1f}%"])
            
        language_table = Table(
            [['Language', 'Files', 'Percentage']] + language_data,
            style=[
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#f1f5f9')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.HexColor('#1e40af')),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('TEXTCOLOR', (0, 1), (-1, -1), colors.HexColor('#374151')),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#e2e8f0'))
            ]
        )
        story.append(language_table)
        story.append(Spacer(1, 30))
        
        # Frameworks Used
        if analysis_data['frameworks']:
            story.append(Paragraph("Frameworks Detected", self.heading_style))
            frameworks_text = ", ".join(analysis_data['frameworks'])
            story.append(Paragraph(f"The following frameworks were detected: {frameworks_text}", self.body_style))
            story.append(Spacer(1, 20))
        
        # Build document with watermark
        doc.build(story, onFirstPage=self.create_watermark, onLaterPages=self.create_watermark)
        
        return output_path

class DocumentExporter:
    """Main class for analyzing codebase and generating documentation"""
    
    @staticmethod
    def analyze_and_export(
        project_path: str,
        output_format: str = 'pdf',
        output_dir: Optional[str] = None
    ) -> str:
        """
        Analyze codebase and generate professional documentation
        
        Args:
            project_path: Root directory of the project to analyze
            output_format: Format of the output document (pdf, html, etc.)
            output_dir: Directory to save the generated documentation
            
        Returns:
            str: Path to the generated documentation file
        """
        # Create analyzer and analyze codebase
        analyzer = CodebaseAnalyzer(project_path)
        analysis_data = analyzer.analyze()
        
        # Setup output directory
        if not output_dir:
            output_dir = os.path.join(project_path, 'docs_output')
        os.makedirs(output_dir, exist_ok=True)
        
        # Generate output filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_filename = f'codebase_analysis_{timestamp}.{output_format}'
        output_path = os.path.join(output_dir, output_filename)
        
        # Generate documentation
        generator = DocumentationGenerator()
        final_path = generator.generate_documentation(analysis_data, output_path)
        
        return final_path
